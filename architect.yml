name: examples/cuttlefish
author: Architect.io

interfaces:
  web: ${ services.web.interfaces.main.url }
  # smtp: ${ services.smtp.interfaces.main.url }
  mailcatcher: ${ services.mailcatcher.interfaces.main.url }

services:
  web:
    build:
      context: ./
      dockerfile: ./web.Dockerfile
    description: Frontend application for cuttlefish
    language: ruby
    interfaces:
      main: 3000
    environment:
      PORT: ${ services.web.interfaces.main.port }
      REDIS_URL: redis://${ services.redis.interfaces.main.host }:${ services.redis.interfaces.main.port }
      CUTTLEFISH_DOMAIN: ${ services.smtp.interfaces.main.host }
    debug:
      volumes:
        app:
          host_path: ./
          mount_path: /app

  guard: #TODO: what is this for?
    build:
      context: ./
      dockerfile: ./web.Dockerfile
    description: TODO
    language: ruby
    interfaces:
    command: bundle exec guard --no-interactions
    debug:
      volumes:
        app:
          host_path: ./
          mount_path: /app

  db:
    image: postgres:10.5
    interfaces:
      postgres: 5432
    environment:
      POSTGRES_DB: cuttlefish_development # TODO: these params need to exist as the database needs to be provisioned before other containers are run. at least a name change is necessary
      POSTGRES_USER: postgres

  smtp:
    build:
      context: ./
      dockerfile: ./smtp.Dockerfile
    description: Cuttlefish SMTP server
    language: ruby
    environment:
      REDIS_URL: redis://${ services.redis.interfaces.main.host }:${ services.redis.interfaces.main.port }
    interfaces:
      main: 2525
    debug:
      volumes:
        app:
          host_path: ./
          mount_path: /app

  redis:
    image: redis:4.0
    interfaces:
      main: 6379

  worker:
    build:
      context: ./
      dockerfile: ./worker.Dockerfile
    description: TODO
    language: ruby
    interfaces:
    environment:
      REDIS_URL: redis://${ services.redis.interfaces.main.host }:${ services.redis.interfaces.main.port }
      POSTFIX_SMTP_HOST: ${ services.postfix.interfaces.main.host }
      POSTFIX_SMTP_PORT: ${ services.postfix.interfaces.main.port }
    debug:
      volumes:
        app:
          host_path: ./
          mount_path: /app

  postfix:
    image: juanluisbaptiste/postfix
    environment:
      SMTP_SERVER: ${ services.mailcatcher.interfaces.smtp.host }
      SMTP_PORT: ${ services.mailcatcher.interfaces.smtp.port }
      SMTP_USERNAME: foo@bar.com
      SMTP_PASSWORD: XXXXXXXX
      SERVER_HOSTNAME: cuttlefish.io
    interfaces:
      main: 25
    debug:
      volumes:
        postfix_logs:
          host_path: ./postfix_log
          mount_path: /var/log

  mailcatcher: # TODO: dev services? this should most likely only be used for development
    build:
      context: ./
      dockerfile: ./mailcatcher.Dockerfile
    description: TODO
    language: ruby
    interfaces:
      main: 1080
      smtp: 1025

  log: # TODO: this needs to be started after the web migrations have already been run at least once. how do we handle this? does the log container have resiliency? or use a readiness probe on the web container?
    build:
      context: ./
      dockerfile: ./log.Dockerfile
    interfaces:
    debug:
      volumes:
        app:
          host_path: ./
          mount_path: /app
        postfix_logs:
          host_path: ./postfix_log
          mount_path: /var/log
